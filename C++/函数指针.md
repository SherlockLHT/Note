- 原理上来说，函数指针和变量的指针是一样的，都是指向内存中的某个地址；

### 一、函数指针的声明

##### C：

```c
返回值类型 (*函数指针名称)(param 1, param 2, ...);
```

##### C++：

```c++
返回值类型 (类名::*函数指针名称)(param 1, param 2, ...)；
```

### 二、函数指针的使用

- 函数指针作为形参和普通数据指针作为形参相同；
- 可以使用`typedef`简写：`typedef int(*PFunction)(int);`，后面可以使用`PFunction`声明函数指针；

#### （1）C语言

- `int (*pf)(int) = NULL;`函数指针的声明；
- `int *pf(int);`缺了括号，就是返回值为`int*`的函数；

```c
int fun1(int temp)
{
    return temp + 1;
}
int fun2(int temp)
{
    return temp + 100;
}

void main()
{
    int (*pf)(int) = NULL;	//声明函数指针并初始化为空指针
	//赋值和调用有两种方法
    //法一
    pf = fun1;
    (*pf)(1);	//2
    //法二，建议使用，因为和变量指针使用方法相同
    pf = &fun2;
    pf(1);	//101
}
```

####  （2）C++

- 全局函数可以使用C语言的写法；
- 只有public权限的函数才能使用函数指针；

类成员写法示例如下：

```c++
class TestClass
{
public:
	int Fun1(int temp){	return temp + 1; }
	int Fun2(int temp) const{ return temp + 10; }
	static int Fun3(int temp){ return temp + 100; }
};
//函数指针作为参数
void TestFun(int(*pf)(int), int temp){
	cout<<pf(temp)<<endl;
}
void TestFun2(int(TestClass::*pf)(int), TestClass& a, int temp){
	cout << (a.*pf)(temp) << endl;
}
void TestFun3(int(TestClass::*pf)(int) const, TestClass& a, int temp){
	cout << (a.*pf)(temp) << endl;
}
//调用
void main()
{
    //static
    int(*pstaticf)(int) = NULL;
	pstaticf = TestClass::Fun3;
	cout << pstaticf(1) << endl;	//101
    TestFun(pstaticf, 1);	//101

	TestClass test_calss;
	//normal function
	int(TestClass::*pf)(int) = NULL;
	pf = &TestClass::Fun1;
	cout << (test_calss.*pf)(1) << endl;	//2
    TestFun2(pf, test_calss, 1);	//2

    //const
	int(TestClass::*pConst)(int) const = NULL;
	pConst = &TestClass::Fun2;
	cout << (test_calss.*pConst)(1) << endl;	//11
    TestFun3(pConst, test_calss, 1);	//11
}
```

### 三、函数指针作为函数参数

```c
typedef int(*PFunction)(int);
//法一：
PFunction TestFunction();	//可读性强，建议使用
//法二
int(*TestFunction(float))(int);	//读起来复杂
```

法二说明：

- `TestFunction`有形参列表，说明其是一个函数；
- `TestFunction(float)`说明该函数形参为`float`类型；
- `TestFunction`前面有`*`，说明该函数返回一个指针类型；
- 最后有`(int)`说明，返回的指针是函数指针，该函数指针有形参，为`int`形；