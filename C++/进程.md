# 1、说明

以前，进程是最小的运行单位，有了线程之后，线程成为最小的运行单位，进程则是线程的容器。

程序本身只是指令、数据及其组织形式的描述，进程才是程序的真正运行实例。

# 2、进程的创建和结束

进程有两种创建方式：操作系统创建、父进程创建

系统启动时，操作系统会创建一些进程，用于管理和分配系统的任务，这些进程称之为系统进程。

linux系统的所有进程是一个数结构，树根是系统自动构造的，即在内核态下执行的 0 号进程，也是所有进程的祖先。

再由 0 号进程创建 1 号进程，1 号进程负责执行内核的部分初始化工作以及进行系统的配置，并创建若干个高速缓存和虚拟贮存管理的内核线程。

随后，1 号进程调用 execve() 运行可执行程序 init，并演变成用户态 1 号进程，即 init 进程。它按照配置文件 /etc/initab 的要求，完成系统的启动工作，创建编号为 1 号、2 号。。。的若干终端注册进程 getty。

每个 getty 进程设置其进程组标识号，并检测配置到系统终端的接口线路。当接收到来自终端的连接信号时，getty 进程将通过函数 execve() 执行注册程序 login，此时用户就可以输入注册名和密码进入登陆过程

总体描述为：0 号进程 -> 1 号内核进程 -> 1 号内核线程 ->1 号用户进程（init 进程） ->getty 进程->shell进程

linux 中，除了 0 号进程外，其他进程都是由父进程创建出来的

创建子进程方法：```pid_t fork(void)```，返回子进程 pid

结束进程的方法：```void exit(int status)```，status 是一个状态值，保存在全局变量 ***$?*** 中

## 2.1、全局变量 $?

***$?*** 是linux shell 中的一个内置的变量，执行 ```echo $?``` 可以查看，其保存最近一次运行的进程的返回值

这个返回值有三种情况：

1. main 函数运行结束的返回值；
2. 调用 exit() 方法退出的传入的参数；
3. 程序异常退出的错误号

# 3、僵尸进程

在 linux 中，正常情况下，子进程的结束和父进程的运行是一个异步过程，即父进程无法宇测子进程什么时候结束，于是就会产生孤儿进程和僵尸进程。

当一个进程完成工作终止之后，应该由其父进程调用 wait() 或者 waitpid() 系统调用取得子进程的终止状态。

***孤儿进程：***

父进程退出，还在运行的子进程，称之为孤儿进程

孤儿进程将被 init 进程（进程号为1的进程）收养，并由 init 进程对它们完成状态收集工作

***僵尸进程：***

子进程退出，但是父进程没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，则这些子进程称之为僵尸进程

# 4、守护进程

脱离终端并在后台运行的进程，为了避免进程在执行过程中的信息在任何终端上显示，以及终端关闭导致进程终止的情况



