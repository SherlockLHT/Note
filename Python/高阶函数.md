# 一、函数作为返回值

我们通常定义和调用函数的方式如下：

```python
def sum(x, y):
    print(x+y)
sum(1, 2)
```

但是现在，不需要立即计算结果，而是在后面的代码中计算，则可以如下方式：

```python
def lazy_sum(x, y):
    def sum():
        print(x + y)
    return sum

fun = lazy_sum(1, 2)	# 将函数调用复制给一个变量
type(fun)	# <class 'function'>
fun()		# 3,需要的时候调用

fun_2 = lazy_sum(1, 2)	# fun和fun_2是两个无关的变量
type(fun_2)	# <class 'function'>
fun_2()		# 3
```

上述代码中，lazy_sum() 方法将函数作为返回值返回，则调用后，fun 变量即是一个函数类型，调用 fun 才会则会执行 lazy_sum() 方法的返回的函数，而返回的函数并没有立即执行

在嵌套函数中，内部函数可以使用外部函数的变量，但是仅限一层嵌套

# 二、闭包

上面例子中，每次调用 lazy_sum() 方法，都会得到一个函数，且每次得到的函数是不同的，传入的参数和返回值都保存在函数中，称之为“闭包”

需要注意的是，上例中，lazy_sum() 方法的参数被 sum() 方法保存，保存的是变量，不是内容，所以，如果参数改变，则执行结果也会随之改变

**示例：**

```python
def lazy_sum(x, y):
    def sum():
        print(x + y)
    x = x + 1
    return sum

fun = lazy_sum(1, 2)
fun()	# 4
```

上例中，sum() 方法并没有立即执行，而执行的时候，变量x已经加一了，所以结果改变

若不得已就是需要在 lazy_sum() 方法中将执行 x+1该如何，只需要再加一层嵌套函数即可

```python
def lazy_sum(x, y):
    def fun(x, y):
        def sum():
            print(x + y)
        return sum
    res = fun(x, y)	#立即执行了x+y，则后面的x+1就无影响
    x = x + 1
    return res

fun = lazy_sum(1, 2)
fun()	#3
```

如上例，lazy_sum() 方法的返回值依旧是一个函数，执行 fun() 之后，才会执行x+y 和 x = x + 1两个表达式

# 三、lambda

各个语言都有不同的lambda的写法，python的写法比较简单，语法如下：

```python
lambda 形参1, 形参2, 形参3, ...: 表达式
```

**示例：**

```python
fun = lambda x, y: x + y

print(fun(1, 2))	#3
```

有了lambda，则上面闭包的写反可以简化如下：

```python
def lazy_sum(x, y):
    def fun(x, y):
        return lambda : print(x+y)
    res = fun(x, y)	#立即执行了x+y，则后面的x+1就无影响
    x = x + 1
    return res

fun = lazy_sum(1, 2)
fun()	#3
```

# 四、装饰器

python的装饰器其实是用了闭包的原理

**示例：**

假设现有一个函数，如下：

```python
def fun(x, y):
    return (x + y)
```

调用后，得到3，该函数在很多地方调用。

## 1、利用闭包扩展函数

但是现在需求变更，要求在调用的地方不变的情况下，该函数的结果翻一倍。

最简单的做法是，修改内部实现，将return的值扩大两倍，这是最简单粗暴的方法，但是这样却破坏了代码的封装性。那么，可以利用闭包，在不改变原方法实现的基础上完成需求，如下：

```python
def fun(x, y):
    return (x + y)

def process(fun):
    def inner(x, y):
        return fun(x, y) * 2
    return inner

fun = process(fun)
```

如上代码中，fun仍然是一个函数，调用之后的结果扩大两倍。

process() 方法的作用，就是将一个函数的结果扩大两倍，但是这里知道原函数是两个参数，若是其他函数也有此需求，但是却没有两个参数呢，比如：

```python
def sub(x):
    return (x - 1)
```

## 2、利用不定参数保证扩展函数的复用性

此时，再用process() 方法来处理，显然不妥当，为了保证 process() 方法的复用性，可以利用python的不定参数，代码如下：

```python
def process(fun):
    def inner(*args, **kw):
        return fun(*args, **kw) * 2
    return inner

def sum(x, y):
    return (x + y)

def sub(x):
    return (x - 1)

sum = process(sum)
sub = process(sub)
```

上述代码中，利用不定参数将传入的形参传给需要修改的函数，保证 process() 方法的复用性

## 3、使用装饰器简化

上面的代码可以使用python的装饰器进行简化

```python
def process(fun):
    def inner(*args, **kw):
        return fun(*args, **kw) * 2
    return inner

@process
def sum(x, y):
    return (x + y)

@process
def sub(x):
    return (x - 1)
```

## 4、带参数的装饰器

还是上面的需求，现在需要结果扩大的倍数由装饰器参数传入，则需要三层嵌套

**代码如下：**

```python
def process(n):
    def func(fun):
        def inner(*args, **kw):
            return fun(*args, **kw) * n
        return inner
    return func

@process(2)
def sum(x, y):
    return (x + y)

@process(4)
def sub(x):
    return (x - 1)
```

## 5、带不定参数的装饰器

需求变为，扩大的倍数可以累积，则代码如下：

```python
def process(*n):
    def func(fun):
        def inner(*args, **kw):
            res = fun(*args, **kw)
            for value in n:
                res = res * value
            return res
        return inner
    return func

@process()
def sum(x, y):
    return (x + y)

@process(2, 3, 9)
def sub(x):
    return (x - 1)
```

利用不定参数，可以动态控制装饰器的参数