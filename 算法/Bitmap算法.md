### 问题：

给40亿个不重复的无符号整数，且没有排序，再给一个无符号整数，判断这个数是否在40亿个数当中？（只有2G内存）

### 思考：

40亿个`unsigned int`数，需要内存如下：

```mathematica
40亿*4/1024/1024/1024 = 14.9G
```

即一个无符号整型占4 byte(32 bit)，若能用1 bit表示一个无符号整型，即可，占用内存如下：

```
40亿/8/1024/1024 = 476.83M
```

内存大小完全可以

### Bit Map算法：

#### （1）基本思想：

举个例子，假设对0~6内的5个数 **5,1,3,6,2**进行存储并排序。这里数据范围最大为7，所致只需要7 bit空间，位置如下：

|  0   | 1    | 2    |  3   | 4    | 5    | 6 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |

先存入5，则在index为5处设置flag，如下：
|  0   | 1    | 2    |  3   | 4    | 5    | 6 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |

再存入1，在index为1处设置flag，如下：

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  0   |  0   |  0   |  1   |  0   |

一次类推，最后如下：

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  1   |  1   |  0   |  1   |  1   |

#### （2）map映射

**假设需要存储排序的最大N = 40,0000,0000，需要申请多大的数组呢？**

一个int占32位，即可以存32个数，那么最大N，需要数组大小为***(N/32+1)***，即

```c
int nums[1 + N/32];
```

**bitmap**表为：

```c
nums[0] -----> 0~31
nums[1] -----> 32~63
nums[2] -----> 64~95
...
```

**如何将数据保存在map映射中呢？**

假设，现在要插入**33**

- index = 33/32 = 1，即插入nums[1]中；
- 33%32 = 1，即插入1中的第1位；

假设，现在要插入**123**

- index = 123/32 = 3，即插入nums[3]中；
- 123%32 = 27，即插入3中的第27位；

代码如下：

```c
void SetMap(int value){
    bitmap[value/32] |= (1 << (value%32));
}
```

检查一个数是否存在，则反向检查是否插入即可

代码如下：

```c
bool TestValue(int value){
    return bitmap[value/32] & (1 << (value%32));
}
```

### 应用

**为了精准定位用户群体，需要对用户信息进行标签化，标签包含用户的社会属性、生活习惯、消费行为等等。**

根据需要，设置数据库表格结构如下：

| name     | sex  | age  | phone  |
| :------: | :--: | :--: | :----: |
| Sherlock | 男   | 90后  | 苹果 |
| Jacky | 男 | 80后 |三星|
| 李四 | 女 | 00后 |小米|

统计使用苹果的用户数目，sql语句为

```sql
select count (distinct name) as from table where phone='苹果';
```

然而，事情没那么简单，标签越来越多，拼接出来的sql语句越来越长，多个用于求并集的时候，要做didtinct，性能实在太慢...

此时可以使用bitmap算法

即先将用户设置成对应的id，然后标签设置程独立的bitmap，包含对应的id即可，保存数据即可，如下：

|    id  | name     |
| :--: | :--: |
| 1 | Sherlock |
| 2 | Jacky |
| 3 | 李四 |

| sex  | bitmap |
| :--: | :----: |
|  男  |  1,2   |
|  女  |   3    |

| age  | bitmap |
| :--: | :----: |
| 90后 | 1 |
| 80后 | 2 |
|00后 | 3 |

| phone | bitmap |
| :---: | :---: |
| 苹果 | 1 |
| 三星 | 2 |
| 小米 | 3 |

**这样，统计用户或者查重，则一目了然，且位运算效率非常高**

例如，性别是男的用户（0110000B）

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  1   |  0   |  0   |  0   |  0   |

使用苹果的用户（0100000B）
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  1   |  0   |  0   |  0   |  0   |

使用苹果的男性用户（0110000B & 0100000B = 0100000B）
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  0   |  0   |  0   |  0   |  0   |

##### 但是bitmap算法不支持非运算，即如果查找性别不是男的用户，则会出错
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  0   |  1   |  1   |  1   |  1   |

如上，查找出的，性别不是男的用户有4个，实际上女性用户只有1一个，所以不能直接使用非运算，但是可以先定义一个全量用户的bitmap，在求非运算，如下：

全量用户（0111000B）

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  1   |  1   |  0   |  0   |  0   |
男的用户（0110000B）
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  0   |  1   |  1   |  1   |  1   |

则性别不是男的用户如下（0111000B XOR 1001111B = 0001000B）：
|  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  0   |  1   |  1   |  1   |  1   |





